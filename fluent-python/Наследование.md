
## super()

Или 
```python
super(type, object_or_type)
# type - начало поиска суперкласса реализующего метод
# object_or_type - объект, от лица которого вызывается метод
```

	Компилятор автоматически подставляет аргументы (Начиная с Python 3)

Python находит нужный метод, и связывает его с `object_or_type`


## Проблема наследования встроенных типов

	Встроенные типы имеют проблему с поздним связыванием

Некоторые методы встроенных типов, могут не вызывать **наших** переопределенных методов, а вызывать базовые

	встроенные методы, как правило, игнорируют написанные пользователем 
	переопределенные методы.


## Множественное наследование

	Проблема ромбовидного наследования - при множественном наследовании классов 
	находятся атрибуты с одинаковым именем


#### Кооперативные методы
Это те методы, которые в своем теле вызывают `super()`

#### MRO

В каждом классе есть атрибут `__mro__` - он содержит кортеж ссылок на классы, в **порядке разрешения** методов множественного наследования
- Методы супер классов ищутся последовательно, в каждом классе `__mro__`
- Принципы
	- Дети идут раньше родителей
	- Родители идут в **порядке перечисления**


#### Порядок наследования
`mro` строит линейную иерархию классов, в результате запись

```python
class Base(A, B)
```

Означает следующее:
```python
B <- A <- Base
```

	Base наследуется от А, А наследуется от B

`__mro__` будет следующим
```python
>>> Base.__mro__
(<class '__main__.Base'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```


**Важно**
Такое наследование (`из листинга 2`) открывает дорогу к **Примесям**


## Классы примеси

```python
class A:  
    def ping(self):  
        print("A")  
  
  
class B:  
    def ping(self):  
        print("B")  
        super().ping()  
  
  
class C(B, A):  
    def ping(self):  
        super().ping()  
  
     
>>> C().ping() # так как B <- A <- C
B
A
```


## Виртуальный подкласс
...

