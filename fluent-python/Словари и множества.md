	Атрибуты классов и экземпляров, пространства имен модулей,
	именованные аргументы функции – вот лишь некоторые фундаментальные
	конструкции, в которых используются словари.

Реализованы на **хэш-таблицах** поэтому операции `проверки` вхождения выполняются за **O(1)** (так же операции добавления и удаление по ключу в словаре)

## Словарные включения

```python
country_dial = {country: code for code, country in dial_codes if code > 25}
```


## Распаковка

Про передачу в функцию опущю

Распаковка внутри словаря **дубликаты перезаписываются**

```python
>>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}
{'a': 0, 'x': 4, 'y': 2, 'z': 3}
```

## Объединение словарей

Словари поддерживают операцию `|` или `|=`

## Match
Словари поддерживают `match/case` операцию. Порядок ключей в образцах не играет роли.

```python
match record:
	case {'type': 'book', 'api': 2, 'authors': [*names]}:
		return names
	case {'type': 'book', 'api': 1, 'author': name}:
		return [name]
	case {'type': 'book'}:
		raise ValueError(f"Invalid 'book' record: {record!r}")
	case {'type': 'movie', 'director': name}:
		return [name]
	case _:
		raise ValueError(f'Invalid record: {record! r}')
```

**Важно**
Все **лишние** пары ключ-значение не учитываются. (То есть в `**_` нет смысла)


## Хэш
Словарь реализован на хэщ таблице, поэтому все ключи должны быть хэшируемыми

	Объект называется хешируемым, если имеет хеш-код, который не изме-
	няется на протяжении всего времени его жизни (у него должен быть ме-
	тод __hash__()), и допускает сравнение с другими объектами (у него дол-
	жен быть метод __eq__()). Если в результате сравнения хешируемых объ-
	ектов оказывается, что они равны, то и их хеш-коды должны быть равны.

методы __eq__() и __hash__() должны принимать во внимание только те атрибуты экземпляра, которые не изменяются на протяжении всей жизни объекта.

## Способы обработки отсутствия ключа

#### Использовать default dict
Можно указать `default_factory` - вызываемый объект, который возвращает значение
Это значение добавляется в словарь, и возвращается **при обращении к несуществующему ключу**

`default_dict` основан на `__missing__` - если при создании defaultdict был указан `default_factory` то в момент обращения к несуществющему ключу, `__missing__` вызовет `default_factory`


## Переопределить метод `__missing__`

	Более правильный способ реализовать тип пользовательского
	отображения – унаследовать классу collections.UserDict а не от dict

В `UserDict` уже написана вся базовая логика

#### Двоякое поведение `__missing__`
```python
>>> UserDictObj['unexsit_key']
Результат __missing__
>>> UserDictObj.get('unexsit_key', '')
Результат __missing__


>>> dictObj['unexsit_key']
Результат __missing__
>>> dictObj.get('unexsit_key', 'Чики брики и в дамки')
Чики брики и в дамки
```


## Виды словарей

- `OrderedDict` - устарел (так как порядок есть в dict с python 3.6)
- `ChainMap` - содержит список словарей, они все используются для просмотра, однако операции **изменения**  происходят только с первым (используется для области  видимости в python)
- `Counter` - принимает последовательность, и считает появление каждого элемента в ней 
- `Shelf` - словарь, но с хранением на диске
- `MappingProxyType` - позволяет только чтение

## Важно знать про словарь

- При использовании должны быть правильно настроены `__eq__` и `__hash__`
- Доступ к элементу по ключу очень быстрый
- Порядок ключей сохраняется с версии Python 3.6
- Словарь расходует много памяти
- Хорошей практикой будет создавать **все** атрибуты объекта в методе `__init__`, так как атрибуты объектов хранятся в `__dict__`, и если был добавлен новый атрибут в коде после `__init__` это заставит python перестроить **ВСЮ** хэш таблицу. 

Про последний пункт

	В python после 3.3 была добавлена оптимизация, что хэш-таблица ОБЩАЯ   
	создается для класса, а объекты класса (__dict__ каждого объекта) содержат  
	ссылки на свои атрибуты.


## Множества
Элементы множества должны быть **хешируемыми**. Сам тип `set` хешируемым
**не является**, поэтому объекты `set` не могут вложенными.
**Однако** тип `frozenset` **хешируемый**, поэтому элементами `set` могут быть объекты типа `frozenset`


## Множественное включение

```python
>>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i),'')}
{'§', '=', '¢', '#', '¤', '<', '¥', 'μ', '×', '$', '¶'}
```


## Важно знать
- Реализованы на основе хэш таблицы
- Проверка на вхождение очень быстрая
- Большие расходы на память
- Добавление элементов в множество может вызвать увеличение размера хэш таблицы и перемешивание объектов. (Это связано с заполненностью хэш таблицы, когда она заполнена на 2/3 то алгоритм множества может работать неэффективно)



## Ключи (и значения) словаря как множество

Ключи словаря поддерживают некоторые операции множества.
```python
>>> d1.keys() & d2.keys()
{'b', 'd'}
```

```python
d1.keys() | {'a', 'e', 'i'}
{'a', 'c', 'b', 'd', 'i', 'e'}
```

	и тд..

Значения словарей тоже это поддерживают **при одном условии** - они являются ***Хэшируемыми*** - в противном случае `TypeError`

