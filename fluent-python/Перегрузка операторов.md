Виды операторов
- Инфиксные `a + b`

## Что такое перегрузка операторов

	Механизм, позволяющий пользовательским объектам взаимодействовать с 
	`инфиксными` операторами


## Опасность

	Перегружая операторы можно не предусмотреть какой-то `use-case` и это 
	сыграет злую шутку

## Механизм диспетчеризации инфиксных операторов

На примере `a + b`
- Интерпретатор проверит, есть ли у `a` метод `__add__`
- Иначе проверяет, есть ли у `b` метод `__radd__` (`инверсный оператор`)
- Иначе `unsupported operand types`

## Унарные операторы

	Не должны никак менять self

- `__neg__` операция унарного минуса (`-instance`)
- `__pos__` операция унарного плюса (`+instance`)
- `__invert__` инверсия `~x = -(x + 1)` 

## Оператор сложения


***Важно***
Интерпретатор проверяет наличие методов, и ловит ***объект*** `(это не исключение)` `NotImplemented` и переходит к другому этапу. 

	Исключения NotImplemented могут быть выброшены нарочно!

***Best practice***

	Eсли специальный метод оператора не может вернуть результат из-за 
	несовместимости типов, он должен возвращать значение NotImplemented, а не 
	возбуждать исключение TypeError. Возвращая NotImplemented, вы оставляете 
	разработчику типа другого операнда возможность выполнить операцию, когда 
	Python попробует вызвать инверсный метод.

## Матричное умножение

С Python 3.5 можно использовать скалярное умножение

```python
a @ b
```

Вызывает методы
```python
__matmul__ 
__rmatmul__
__imatmul__
```

	В стандартной библиотеке не используется


## Операторы составного присваивания

	Для неизменяемых типов создают новый объект и связывают его с переменной

***Важно***
Если в классе, не реализованы операторы `на месте` то вызов
```python
a += b
```

просто **shortcut** к 
```python
a = a + b
```

