
	Декоратор - это вызываемый объект, который принимает в качестве аргумента 
	вызываемую функцию. Декоратор может возвращать либо саму переданную функцию 
	(или другую), либо любой другой вызываемый объект

Плюс декоратора - изменения поведения программы в процессе ее выполнения.

Важные факты:
- Декоратор - это функция или другой вызываемый объект
- Декоратор может **заменить** декорирующую функцию **другой**
- Декораторы выполняются **после загрузки модуля**

#### Про второй пункт

```python
def deco(func):  
    def inner():  
        print('running inner()')  
    return inner  
  
@deco  
def target():  
    print('running target()')  
  
  
>>> target()
running inner() # Функция target заменилась на inner

>>> target
<function deco.<locals>.inner at 0x7fe6ee472840> 
# ЗАМЕНИЛАСЬ !!! Так как мы вернули return inner 
```

## Когда выполняются декораторы 

Выполняются они сразу после определения декорируемой функции ещё до вызова функции, **обычно на этапе импорта**


## Правила видимости переменных

#### Важно
При компиляции функции, Python анализирует ее содержимое, если внутри есть обращение к переменной, которая не объявлена в рамках функции, то поведение функции зависит от того, есть ли эта переменная уровнем выше, и какой тип обращения используется (**чтение** или **чтение и присваивание**). В случае:
- `Чтения` - если данная переменная есть уровнем выше, то она успешно прочитается, если нет, то `Crash`
- `Изменение` - при записи переменных возникнет ошибка
- `Чтение и Изменение` - Если в блоке функции, есть **чтение переменной** до ее **присваивания**, то интерпретатор соберет байт код, с учетом того, что операция **чтения** выполнятся с ***переменной объявленной локально***, и будет ***ошибка*** на этапе ***чтения***

```python
b = 6  
def f3(a):  
    print(a)  
    print(b)  
    b = 1  
>>> f3(3)
3
UnboundLocalError: cannot access LOCAL variable 'b' where it is not associated with a value
```


## Замыкания

	Замыкания - это функция с расширенной областью видимости, которая запоминает 
	ссылки переменных, существоваших на момент определения функции, и может их
	использовать даже после уничтожения той области видимости, в которой они были
	объявлены

```python
def make_averager():
	series = []
	def averager(new_value):
		series.append(new_value)
		total = sum(series)
		return total / len(series)
	return averager

>>> avg = make_averager()
>>> avg(10)
10
```

Но как `series` сохраняется, ведь к вызову `avg(10)` функция `make_averager` уже передала управление функции `averager` и ее локальная область **видимости уже уничтожена**

Объект функции хранит имена своих переменные в атрибуте `__core__` переменная `series` стала ***свободной переменной*** (название находится в `__code__.co_freevars`)

А **значения** свободных переменных лежат в `__closure__` - он содержит объекты ячеек `cell` у которых есть `cell_contents` - сами значения


## nonlocal

	Чтобы "перепривязывать" свободные неизменяемые перменные можно использовать 
	nonlocal

```python
def make_averager():
	count = 0
	total = 0
	def averager(new_value):
		nonlocal count, total
		count += 1
		total += new_value
		return total / count
	return averager
```

Без `nonlocal` при операции **изменения** (+=) интерпретатор будет ожидать, что существует переменная `count` в локальной области видимости, но ее нет поэтому `Error`

	Читать их можно без проблем не используя nonlocal

## Логика поиска 

- Если объявлено `global x` то берется переменная уровня **модуля**
- Если объявлено `nonlocal x` то берется переменная **ближайшей** объемлющей функции в которой **x определена**
- Если x `параметр` или ей присвоено значение в `теле функции`, то x - локальная переменная
- Если x используется, но локально не объявлено, то 
	- Ищется в объемлющих 
	- Ищется на уровне модуля
	- Ищется в `__builtins__.__dict__`


**Важно**

- `globals` выводит словарь текущего модуля (в котором объявлен, а не в который импортится)



## Декораторы стандартной библиотеки

#### functools.wraps

	Копирует метаданные (__name__, __doc__ и тд) декорируемой функции во 
	внутреннюю функцию

```python
from functools import wraps

def decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        # Дополнительное поведение
        return func(*args, **kwargs)
    return wrapper

@decorator
def my_function():
    """Оригинальная функция"""
    pass

>>> print(my_function.__name__)
my_function
>>> print(my_function.__doc__)
Оригинальная функция
```


#### functools.cashe

**Кэширует результат** выполнения функции результат должен быть **хэшируемым** - иначе `TypeError`

```python
@functools.cache  
def fibonacci(n):  
    if n < 2:  
        return n  
    return fibonacci(n - 2) + fibonacci(n - 1)
```

**Важно**
При его использовании может закончится память, так как он не накладывает ограничения на кэш


#### functools.singledispatch

	Перегрузка в Python... Ебануться

Для этого необходимо пометить функцию декоратором
```python
@singledispatch
def base_func_name(x)
```

После этого, можно создавать функции (можно даже с именем `_`) и добавить им декоратор 
```python
@base_func_name.register
```

Перегрузка:
- В параметрах дочерних методов можно добавить аннотацию типа, который ожидается
- В `.register` можно добавить ожидаемый тип `.register(fractions.Fraction)`

**Примеры**
```python
@singledispatch
def htmlize(obj: object) -> str:
	content = html.escape(repr(obj))
	return f'<pre>{content}</pre>'

@htmlize.register(float)
def _(x) -> str:
	frac = fractions.Fraction(x).limit_denominator()
	return f'<pre>{x} ({frac.numerator}/{frac.denominator})</pre>'

@htmlize.register
def _(text: str) -> str:
	content = html.escape(text).replace('\n', '<br/>\n')
	return f'<p>{content}</p>'
```

**Важно**
- Можно компоновать (несколько декораторов на один метод)
- Находит самое ближайшее совпадение с типом

#### functools.lru_cashe
То же самое, только можно установить максимальное количество кэшируемых элементов
`functools.cashe` использует эту функцию, затирая максимальный кэш



Без использования `wraps` выведет
```python
>>> print(my_function.__name__)
wrapper
>>> print(my_function.__doc__)
None
```


## Параметризованные декораторы

	Или по другому, фабрика декораторов

Строится по шаблону

```python
def register(params):
	def decorate(func):
		return func # Или что то другое
	return decorate
```

```python
@register(params=2)  
def a(param1):  
    print(f"A HELLO FROM {param1}")
```

**Как мне кажется**

	Так как код выполняется справа налево, то сначала выполнится функция 
	register, которая вернет функцию decorate, а конструкция @ зарегестриурет  
	decorate как декоратор


## OffTopic


```python
@decorator
def a()
```

то же самое что и

```python
a = decorator(a)
```

#### Вложенность
```python
@alpha
@beta 
def my_fn():
```

```
my_fn = alpha(beta(my_fn))
```
