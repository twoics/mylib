

## Контекстные менеджеры

	Если проводить аналогию, то похож на try/finaly 


#### Интерфейс

Содержит методы
- `__enter__` - вызывается в начале блока with
- `__exit__` - вызывается при завершении блока, естественным или нет образом

**ВАЖНО**
- **Объект контекстного менеджера** - это результат вычисления который находится сразу после `with`
- Переменная после `as` - хранит результат выполнения `__enter__` **объекта контекстного менеджера** 
- При выходе из блока вызывается `__exit__` у **объекта контекстного менеджера** а не у объекта, который вернул `__enter__`
- `as` опционально, в некоторых случаях можно обойтись без него


#### Можно представить его работу так

```python
some_manager.__enter__()
... # some code
some_manager.__exit__()
```

## contextlib

	Содержит много полезных контекстных менеджеров

#### Контекстный менеджер при помощи декоратора 

```python
@contextlib.contextmanager
def some_function():
	# Здесь код который выполняется в __enter__
	yield то что должкн вернуть __enter__
	# Здесь код который выолняется в __exit__
```

**ВАЖНО**
но тут есть дефект, если внутри `with` возникнет исключение, то интерпретатор **повторно возбудит** его в месте вызова `yield` и если не стоит **обработки исключений** 
то функция аварийно завершится, не вызвав код после `yield`


## EAFP

	Лучше попросить прощения, чем спрашивать разрешения

В Python это принятый и приветсвующийся стиль программирования. 
Юзаем  try/catch

## LBYL

	Не зная броду не суйся в воду

Много ифов и проверок