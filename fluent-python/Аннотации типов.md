
	«Типы определяются тем, какие операции они поддерживают»

Типы кортежей:
- Кортежи с заданным числом элементов `lat_lon: tuple[float, float])`
- Кортежи с неизвестным числом элементов `lat_lon: tuple[str, ...]`

Принцип хорошего кода будет - ***принцип Постела***

	Будь либерален когда принимаешь
	будь консервативен когда отдаешь

Это значит, что аргументам лучше иметь обобщенный тип (`Sequence` или `Iterable`) а возвращаемым значениям быть конкретными (`list`, `set`, `tuple`)


## TypeVar


## Протоколы
Позволяют декларировать, какие методы доступны в объектах передающихся в функцию

```python
from typing import Protocol, Any
class SupportsLessThan(Protocol):
	def __lt__(self, other: Any) -> bool: ...
```

```python
LT = TypeVar('LT', bound=SupportsLessThan)
def top(series: Iterable[LT]) -> list[LT]:
	pass
```

Главное **преимущество** протоколов перед написанием абстрактных классов - это то, что не нужно писать эти самые абстрактные классы, это открывает доступ к спокойному использованию уже **существующих типов**, которые **реализует запротоколированные методы**

## Callable

```python
Callable[[ParamType1, ParamType2], ReturnType]
```


## Аннотация args и kwargs

#### Args

- `*args: str` - элементы будут иметь тип `str`

#### kwargs

- `**kwargs: int` - элементы будут типа `{str: int}`
- `**kwargs: Union[int, float]` - элементы будут типа `{str: int | float}`
## OffTopic

	Константа typing.TYPE_CHECKING во время выполнения всегда равна False, но
	средства проверки типов во время работы притворяются, что она равна True

