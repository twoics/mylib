
Когда применяются
- Операция `for`
- Включения
- Операции распаковки
- Конструирование коллекций

## Почему последовательности - итерируемые объекты

Когда итератору нужно обойти последовательность он вызывает функцию `iter(x)`
что она делает:
- Проверяет, реализует ли объект метод `__iter__`, если да то вызывает его
- Иначе проверяет реализует ли объект метод `__getitem__` если да, то интерпретатор создает итератор который извлекает элементы по индексу, начиная с `0` до `IndexError`
- Если это не получается -> raise Exception


#### Проверка что объект поддерживает итерацию

	Самый простой способ вызвать 

```python
try:
	iter(x)
except SomeException:
	not iterable
```

Так как вызов `iter` проверит не только существование `__iter__` но и `__getitem__`


## Iter and Callable

	Можно создать итератор из любого вызываемого объекта, который будет работать
	до тех пор, пока не вернет указанное значение

```python
def func():
	return randint(1,6)

>>> d6_iter = iter(func, 1)
>>> for i in d6_iter:
		print(i)
5
3
2
6
```

Код в примере выше будет вызываться до тех пор, ***пока результат не будет равен 1***


## Итерируемые объекты и итераторы

`Итерируемый объект` - любой объект, от которого функция `iter(x)`  может получить ***итератор***


Итератор выполняется до `StopIteration`

#### Интерфейс итератора

- `__next__` возвращает следующий элемент, или возбуждает `StopIteration`
- `__iter__` возвращает `итератор`, это позволяет использовать **класс**, как `итерируемый объект`. Чаще всего это используется **неявно** - при вызове `for` или `распаковке` (***НО ЧИТАЙ ВРЕЗКУ НИЖЕ***)

## Антипаттерн

	Не стоит делать итерируемый объект итератором самого себя

- У **итерируемого объекта** - есть метод `__iter__` который возвращает новый итератор

- **Итератор** реализует метод `__next__` который возвращает элементы, и метод `__iter__` который возвращает `self`

Следовательно **итератор** является **итерируемым объектом**, но **итерируемый объект** не является **итератором**


Из за всей этой путаницы возникает желание сделать итерируемый объект итератором и добавить в него метод `__next__`

Но это является ***антипаттерном*** - так как не поддерживает несколько активных обходов


## Генераторная функция

Генераторная функция - функция в теле которой вызывается `yield` при вызове она возвращает **объект генератор**. (`Фабрика генераторов`)

	Объекты-генераторы реализуют интерфейс Iterator


