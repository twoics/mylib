Вот они, слева направо:
- namedtuple `namedtuple('Coordinate', 'lat lon')`
- NamedTuple `typing.NamedTuple('Coordinate', [('lat', float), ('lon', float)])` (тут просто можно указывать типы)
- `@dataclass`

Все они реализуют основные методы **учитывая атрибуты**, такие как `__eq__` `__repr__` `__init__`

#### Различие
Ключевое различие между ними - `namedtuple` и `NamedTuple` не изменяемые, а `@dataclass` изменяем - **однако** это можно изменить указав `frozen=True`

#### Что позволяют
- Предоставляют методы конструирования словаря из значений `._asdict` и `.asdict` соответсвенно
- Получение названий полей и их дефолтных значений `._fields, ._fields_defaults` и `.fields`
- В `NamedTuple` и `@dataclass` доступно `__annotations__` получать их рекомендуется через `typing.get_type_hints`

## Введение в аннотации
Создадим объект класса
```python
class DemoPlainClass:
	a: int
	b: float = 1.1
	c = 'spam'
```

Просмотрим его аннотации
```python
>>> DemoPlainClass.__annotations__
{'a': <class 'int'>, 'b': <class 'float'>}
```

- **c** - это не аннотация, а атрибут класса
- **b** - добавляется в аннотации, и становится атрибутом класса
- **a** - только добавляется в аннотации

## namedtuple
```python
collections.namedtuple('Card', ['rank', 'suit'])
```

- Можно указать значения по умолчанию, используя  `defaults=[SomeThing]`
- Можно получить названия полей объекта через `._fields`
- Можно получить представление в виде словаря, через `._asdict`

## typing.NamedTuple

```python
class DemoNTClass(typing.NamedTuple):
	a: int
	b: float = 1.1
	c = 'spam'
```

- **a** - для него заводится атрибут и оно **становится атрибутом класса**
- **b** - для него заводится аннотация и оно становится атрибутом со значением 1.1
- **c** - просто атрибут класса

Атрибуты **a** и **b** являются ***дискрипторами***, доступными **только для чтения** (можно сказать это просто `getter` )

**Важно**
Обращение к `DemoNTClass.a` вернет `_tuplegetter`, обращение к `DemoNTClass.b` тоже
а обращение к **c** вернет `spam`

	После создание экземпляра, а тоже станет атрибутом
## @dataclass
```python
@dataclass
class DemoDataClass:
	a: int
	b: float = 1.1
	c = 'spam'
```

- **a** - для него заводится атрибут и оно ***не** **становится атрибутом**
- **b** - для него заводится аннотация и оно становится атрибутом со значением 1.1
- **c** - просто атрибут класса

**Важно**
Обращение к `DemoNTClass.a` выкинет **AttributeError**, обращение к `DemoNTClass.b` вернет 1.1, а обращение к **c** вернет `spam`

	После создания экземпляра а тоже станет атрибутом

#### Параметры конструктора
У него есть несколько параметр, которые влияют на сгенерированные методы, см доку

#### Изменяемое значение по умолчанию

@dataclass  выкидывает `ValueError` когда, в качестве значения по умолчанию указывается **list** **set** **dict**

Это относиться ***только к этим*** изменяемым типам!

Для их создания можно использовать `default_facotry`

#### Постинициализация
Можно реализовать метод `__post_init` который вызывает в последний шаг выполнения метода `init`

#### Создания типизированного атрибута класса
Чтобы создать типизированный атрибут именно **класса**, то можно использовать синтаксис `ClassVar`
```python
all_handles: ClassVar[set[str]] = set()
```

#### Переменные только для инициализации
```python
@dataclass
class C:
	i: int
	j: int = None
	database: InitVar[DatabaseType] = None

	def __post_init__(self, database):
		if self.j is None and database is not None:
			self.j = database.lookup('j')
```

```python
>>> c = C(10, database=my_database)
```

В данном случае `database` передается в конструктор класса, но оно **не будет** добавлено в **атрибуты экземпляра**

#### Code smells
В книге про рефакторинг сказано, что датаклассы признак дурного тона, потому что принцип ооп собрать данные и методы в одном месте

Однако, есть пара случаев, когда это уместно использовать
- Временный класс
- Как данные, пересекающие какие-то границы, при том в **неизменяемом** виде

## Сопоставление с образцом


**Важно** 
```python
match x:
	case float: # ОПАСНО!!! Так как сопоставляется с любым субъектом
	do_something_with(x)
```

##### Именованные классы образцы

	Сопоставление с азиатскими городами

```python
match city:
	case City(continent='Asia', country=cc):
	some.method(cc)
```

##### Позиционные классы образцы
Любой класс, может работать в позиционном режиме, если у него реализован метод `__match_args__`

Работает по аналогии

```python
match city:
	case City('Asia', _, country):
	some.method(cc)
```
