
## Генераторная функция

	Функция в теле которой встречается yield

При вызове возвращает объект **генератор**

#### next
При передаче **генератора** функции `next(i)` выполнение функции продолжается до следующей конструкции `yield x`, и вернет значение `x`
При возврате из функции (**return**) вызывается `StopIteration` 

	Соответсвие протоколу итератора

**Важно**
Генераторные функции ***откладывают свое выполнение*** 

## Ленивые вычисления

	Когда реализуешь итератор, хорошей практикой будет производить ленивые 
	вычисления


(Как пример, а не запихивать весь список в память при инициализации)


## Передача генераторных выражений

	Когда генераторное выражение передается в качестве единственного аргумента 
	скобки можно опустить

```python
return Vector(n * scalar for n in self)
```


## Итератор и Генератор

- **Итератор** - общий термин, обозначающий любой объект, реализующий метод `__next__`. Осуществляет получение значений через `next()`
- **Генератор** -  итератор, построенный компилятором Python. Только вместо реализации метода `__next__` мы прописываем `yield`


## itertools

	В itertools лежит очень много полезных генераторных функций


## yield from

	Из одного генератора можно деллигировать работу субгенератору. Во время
	этого делигирующий генератор ожидает завершения субгенератора, после чего 
	выполняется дальше. Так же все значения отдаваемые субгенератором передаются 
	клиентскому коду

```python
def sub_gen():
	yield 1.1
	yield 1.2
def gen():
	yield 1
	yield from sub_gen()
	yield 2

>>> for x in gen():
		print(x)

1
1.1
1.2
2
```

**Важно**
Результат **return** субгенератора то его можно перехватить делигирующим генератором

```python
def sub_gen():
	yield 1.1
	return 'Done!'

...
>>> result = yield from sub_gen()
>>> result
Done!
```


## Обобщенные итераторы
```python
FromTo: TypeAlias = tuple[str, str].

def a(var: Iterable[FromTO])
```

## Классические сопрограммы

```python
Generator[YieldType, SendType, ReturnType]
```

- `yield type` - отдаваемое значение
- `send type` - принимаемое значение
- `return type` - возвращаемое значение

**Важно**
Локальные переменные могут быть использованы для запоминания контекста ***во время ожидания сопрограммы***


Пример

```python
def averager() -> Generator[float, float, None]:  
    total = 0.0  
    count = 0  
    average = 0.0  
    while True:  
        term = yield average  
        total += term  
        count += 1  
        average = total / count  
  
  
>>> average = averager()
>>> next(average)
>>> average.send(19)
19.0
>>> average.send(25)
21.0
```


#### Разбор

- вызов `next(average)` заставляет сопрограмму дойти до `yield`
	- запустить можно и при помощи `average.send(None)` - так и поступает `next()`
		- отправить значения кроме `None` в первый раз нельзя, так как сопрограмма принимает значения только когда приостановлена в `yield`
- после каждой активации сопрограмма останавливается на `yield` и ждет отправки значения
- закрыть сопрограмму явно можно при помощи `.close()` либо сборщик мусора его сам почистит


## Важная деталь в сопрограммах

Выдать значение tmp и ожидать отправки `send(x)` для установки x как значение для `some`
```python
...
some = yield tmp
```

Выдать `None` и ожидать отправки `send(x)` для установки x как значение для `some`
```python
...
some = yield
```

