Встроенные последовательности:
- `Контейнерные` которые содержат в себе ссылку на значение. Может содержать в себе ссылки на любые элементы **list** t**tuple** 
- `Плоские` хранят сами значение - **str** **bytes** **array.array**

`array` чисел гораздо компактнее `tuple` чисел (так как не содержит прослойки)

Можно ещё класифицировать последовательности по изменяемости:
- Изменяемые (list, bytearray, array.array)
- Неизменяемые (tuple, str, bytes)

## Списковое включение

Область видимости
В списковых включениях является только границами самого спискового включения, однако, при помощи `:=` можно прокинуть в объемлющую область (так как область видимости этого оператора - объемлющая)

```python
codes = [last := ord(c) for c in x]
>>> last
67
```

Можно делать такие вещи
```python
[(color, size) for color in colors for size in sizes]
```


## Генераторное выражение

Синтаксис похожий на списковое включение, только вместо `[]` используется `()`

Однако, самое главное отличие - генераторное выражение отдает циклу
for по одному элементу. А списковое включение создает весь список


## Кортежи

Так как кортеж неизменяем, его можно использовать как хранилище значений полей, где позиция поля будет отображать его семантику

```python
city, year, pop, chg, area = ('Tokyo', 2003, 32_450, 0.66, 8014)
```

Когда думаешь про **неизменяемость** кортежей, всегда держи в голове, что это означает только неизменяемость **ссылок** которые хранит в себе кортеж !

	Объект допускает хеширование только тогда, когда его значение никогда не 
	изменяется.

Цитата выше означает, что можно проверить, является ли кортеж **фиксированным** (содержит только неизменяемые объекты)
```python
>>> tf = hash((10, 'alpha', (1, 2)))
>>> -9176758080175910295
>>> tm = hash((10, 'alpha', [1, 2]))
>>> TypeError
```

## Распаковка
Можно использовать при паралельном присваивании

```python
>>> a, b, *rest = range(5)
>>> a, b, rest
(0, 1, [2, 3, 4])

>>> a, *body, c, d = range(5)
>>> a, body, c, d
(0, [1, 2], 3, 4)
```


**Важно**
```python
>>> a, *body, c, d = range(3)
>>> a, body, c, d
(0, [], 1, 2)
```


**Важно**
Распаковка с сохранением структуры вложенности

```python
# ('Tokyo', 'JP', 36.933, (35.689722, 139.691667))
for name, _, _, (lat, lon) in metro_areas:
```


## Match
Это нечто большее, чем просто switch/case

Самый базовый синтаксис:
```python
for i in range(10):  
    match i:  
        case 1:  
            print("Hello")  
        case 5:  
            print("World")  
  
        case _:  
            print("WOW")
```

Однако, match реализует сопостовление с `объектами последовательностей`

Это означает, что он автоматически применяет деструктуризацию (`распаковку`) к **субъекту** далее идет **сопоставление** с образцом в ветве, `case` которая при успешном выполнении может использовать `фильтрацию`

**Сопоставление** считается удачным если:
- субъект является последовательностью
- субъект и образец содержат одинаковое число элементов
- все соответственные элементы, включая вложенные, совпадают

```python
match record:
    case [name, _, _, (lat, lon)] if lon <= 0: 
		print(f'{name:15} | {lat: 9.4f} | {lon: 9.4f}')
```

**Несколько фишек**
- str, bytes и bytearray не считаются последовательностями в контексте match/case (это означает, что, допустим, строка считается атомарной, и сопоставление происходит с ней целеком)
- `case [str(name), _, _, (float(lat), float(lon))]` в контексте образца эта синтаксическая конструкция производит проверку типа элемента последовательности
- Можно использовать распаковку `case [str(name), *_, (float(lat), float(lon))]`


## Срезы
Для реализации функциональности среза, python использует объект `slice`

Присваивание срезу:
- Срезу можно присвоить последовательность
	- Если **срез больше** чем последовательность, то остатки **среза** сотрутся
		- `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`
		- `l[2:8] = [99, 99]`
		- `[0, 1, 99, 99, 8, 9]`
- Срез можно удалить `del l[5:7]`
- Срезу **нельзя** присвоить **НЕ** последовательность

## Операнды последовательностей
Операторы + и * всегда создают новый объект и никогда не изменяют свои
операнды.

**Важно**
Нужно быть аккуратным с `a * n`, где a – последователь-ность, содержащая изменяемые элементы

	при попытке инициа­лизировать список списков `my_list = [[]] * 3` получится 
	список, содержащий три ссылки на один и тот же внутренний список

```python
>>> my_list = [[]] * 3
>>> my_list[0].append(1)
>>> my_list
[[1], [1], [1]]
```



## Составное присваивание
Поведение опреаторов вида (`+=` `*=` и тд) зависит от **типа первого операнда**

Разбор на основе `+=` он вызывает метод `__iadd__` (`i` - inplace) если он реализован, то вызывается просто `__add__`

**ВАЖНО**
Составное присваивание - это **не атомарная** операция, и она может вызвать исключение в середине работы
```python
>>> t = (1, 2, [30, 40])
>>> t[2] += [50, 60]
```


## OffTopic

	int PySequence_Check(PyObject *o) возвращает 1 если объект реализует протокол 
	последовательности 0 иначе.

```python
# Возврашает 1 для классов которые реализуют, только если они не подклассы dict
def __getitem(self, index)
```

