При создании конфигурируется:
- `bootstrap servers` Список (host:port) брокеров, используемых продюсером для соединения с кластером (рекомендуется указывать хотя бы два, чтобы была возможность подключиться в случае отвала первой ноды)
- `key serializer` Используется для сериализации ключей 
- `value serializer` Используется для сериализации значений
- `group.id` Идентификатор группы
- `fetch.min.bytes` Указывает минимальный объем данных, при которых потребитель начинает их чтение (До этого брокер принимает сообщения и копит их до достижения данного объема)
- `fetch.max.wait.ms` Максимальное время ожидание, которое потребитель ждет, ожидая новые данные (Связан с предыдущим)
- `max.partition.fetch.bytes` Указывает, **максимальный размер данных**, которые могут быть прочитаны из одного раздела ***за один запрос*** (вызов `poll`).
	- Логично, что это значение должно быть больше максимального размера сообщения
	- Если поставить слишком большое значение, то возможно потребитель не успеет обработать сообщение до вызова `heartbeat` в результате чего будет считаться упавшим

- `session.timeout.ms` Максимальное время, которое потребитель может быть вне связи с брокером
	- Связан с параметром `heartbeat.interval.ms` - обычно это значение составляет треть от `session.timeout.ms`
	- Слишком маленькое значение этого параметра может быть причиной долгой работы, либо ненужной перебалансировки

- `auto.offset.reset` Определяет, откуда читать потребителю при отсутсвии или некоркетном значение смещения
	- `earliest` Начинать с самых ранних
	- `latest` Начинать с самых поздних

- `enable.auto.commit` Будут ли потребители фиксироваться смещения автоматически.
	- Если `true` можно установить частоту фиксаций `auto.commit.interval.ms`

- `partition.assignment.strategy` Определяет какие разделы к какому потребителю будут относится 
	- `range` Имеются 2 темы, по 3 раздела, к ним подсоединены 2 потребителя (П1, П2). В данном случае П1 получит два первых раздела из первой и второй темы. А П2 получит последние разделы из первой и второй темы
	- `round` Все разделы на которые подписаны потребители распределяются последовательно (Самый популярный сценарий)

- `client.id` Тут понятно
- `max.poll.records` Максимальное число записей, при одном вызове `poll`